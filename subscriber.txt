#include <iostream>
#include <cstring>
#include <cstdlib>
#include <mqtt/async_client.h>

// MQTT Broker Settings
const std::string MQTT_BROKER_ADDRESS("tcp://broker.hivemq.com:1883");
const std::string MQTT_CLIENT_ID("raspi_gas_subscriber");
const std::string MQTT_TOPIC("gas_sensor/data");
const int QOS = 1;

// Callback for when a message arrives
class callback : public virtual mqtt::callback {
public:
    void message_arrived(mqtt::const_message_ptr msg) override {
        std::cout << "Gas Sensor Data Received: " << msg->get_payload_str() 
                  << " (Topic: " << msg->get_topic() << ")" << std::endl;
        
        // Here you could add code to display on an LCD screen
        // For example: lcd_display(msg->get_payload_str());
    }

    // Optional: Add LCD display function
    /*
    void lcd_display(const std::string& message) {
        // Implement your LCD display logic here
        // This would be specific to your LCD hardware
    }
    */
};

int main(int argc, char* argv[]) {
    try {
        // Create an MQTT client
        mqtt::async_client client(MQTT_BROKER_ADDRESS, MQTT_CLIENT_ID);
        
        // Set up callback
        callback cb;
        client.set_callback(cb);
        
        // Connect options
        mqtt::connect_options connOpts;
        connOpts.set_keep_alive_interval(20);
        connOpts.set_clean_session(true);
        
        // Connect to the broker
        std::cout << "Connecting to MQTT broker..." << std::endl;
        mqtt::token_ptr conntok = client.connect(connOpts);
        conntok->wait();
        std::cout << "Connected!" << std::endl;
        
        // Subscribe to the topic
        client.subscribe(MQTT_TOPIC, QOS);
        std::cout << "Subscribed to topic: " << MQTT_TOPIC << std::endl;
        
        // Keep the program running to receive messages
        while (true) {
            // You could add other processing here
            // For a simple subscriber, we just sleep
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
        
        // Disconnect (though we may never reach here)
        client.disconnect()->wait();
        std::cout << "Disconnected" << std::endl;
    }
    catch (const mqtt::exception& exc) {
        std::cerr << "Error: " << exc.what() << std::endl;
        return 1;
    }
    
    return 0;
}